//Scott Saunders
//10163541
//Cpsc 453 template 
//October 1st, 2016.



// #include <GL/glew.h>  //DONT USE? WHY IDK.
#define GLFW_INCLUDE_GLCOREARB
#define GL_GLEXT_PROTOTYPES

#include <GLFW/glfw3.h>
#include <unistd.h>
#include <stdio.h>

#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <iterator>
#include <sstream>

#include <stdlib.h> 

#include "gl_helpers.cpp"
#include "parser.cpp"

#define WIDTH 512
#define HEIGHT 512

// #define twoprogs

using namespace std;
int scene=0;
bool initalized=false;

GLfloat vertices[]={
	-1,	1,
	-1,	-1,
	1,	1,
	1,	-1,
};


GLuint texture;
GLuint tdraw;
GLuint cprog;
GLuint vbo;
GLuint vao;
GLuint array;

#define MAX_SCENE 2
void changeScene(){
	if(scene > MAX_SCENE)
		scene = 0;
	if(scene < MAX_SCENE )
		scene = MAX_SCENE;
	if(scene == 0){
		vector<GLfloat> objects = parse("scene1.txt");
	}else if(scene == 1){
		vector<GLfloat> objects = parse("scene2.txt");
	}else if(scene == 2){
		vector<GLfloat> objects = parse("scene3.txt");
	}

	if(!initalized){
		initalized=true;
		
		
		//Following OpenGL wiki example:
		
		GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);
		cout << vertexShader << endl;
		string source = LoadSource("vertex.glsl");
		const GLchar *source_ptr = source.c_str();

		glShaderSource(vertexShader, 1, &source_ptr, 0);
		glCompileShader(vertexShader);
		check_compile(vertexShader);


		glClearColor(0.2, 0.2, 0.2, 0.0);

		GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
		cout << fragmentShader << endl;
		source = LoadSource("fragment.glsl");
		source_ptr = source.c_str();

		glShaderSource(fragmentShader, 1, &source_ptr, 0);
		glCompileShader(fragmentShader);
		check_compile(fragmentShader);
		
		cout << "NUGGETS" << endl;
//		cout << vertexShader << " " << fragmentShader << endl;		
		#define program tdraw
		#define cprog tdraw
		//GLuint program = glCreateProgram();
		glAttachShader(program, vertexShader);
		glAttachShader(program, fragmentShader);
		
		glLinkProgram(program);
		check_gllink(program);
		
		/*glBindBuffer(GL_ARRAY_BUFFER, vbo);
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
		GLint posAttrib = glGetAttribLocation(tdraw, "VertexPosition");
		glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 0, 0);
		glEnableVertexAttribArray(posAttrib); */

		glGenBuffers(1, &vbo); // Generate 1 buffer	
		glGenVertexArrays(1, &vao);


		glBindVertexArray(vao);
		glEnableVertexAttribArray(vao);
 

		#define VERTEX_INDEX 0
		glBindBuffer(GL_ARRAY_BUFFER, vbo);	
//		glVertexAttribPointer( 0, 2, GL_FLOAT,  GL_FALSE,  sizeof(GLfloat)*2,  (void*)0 );
		glVertexAttribPointer(VERTEX_INDEX, 2, GL_FLOAT, GL_FALSE, 0, 0);
		glEnableVertexAttribArray(VERTEX_INDEX);			
		
		glBindBuffer(GL_ARRAY_BUFFER, vbo);
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
		

/*
		//Initalize stuff
		//
		tdraw = glCreateProgram();		
//		GLuint progHandle = glCreateProgram();

		//glUseProgram(tdraw);					//Initalize the "texture draw" program.
		//glGenBuffers(1, &vbo); 
		//glBindBuffer(GL_ARRAY_BUFFER, vbo);		//Initalize full-screen array
		//glBufferData(GL_ARRAY_BUFFER, sizeof(vertexpos), vertexpos, GL_STATIC_DRAW);

//		cout << LoadSource("vertex.glsl") << endl;
		GLuint vshader = CompileShader(GL_VERTEX_SHADER, LoadSource("vertex.glsl"));
		GLuint fshader  = CompileShader(GL_FRAGMENT_SHADER, LoadSource("fragment.glsl"));
		
//		glAttachShader(tdraw, vshader);
//		glAttachShader(tdraw, fshader);
	#ifdef twoprogs
		glLinkProgram(tdraw);	
		Check_gllink(tdraw);
		check_glerror();
		cprog = glCreateProgram();
	#else	
		#define cprog tdraw
	#endif
		cout << "PANCAKES" << endl;
		GLuint cshader = CompileShader(GL_COMPUTE_SHADER, LoadSource("compute.glsl"));
		glAttachShader(cprog, cshader);
		LinkProgram(cprog);
		Check_gllink(cprog);
		check_glerror();
		
		
		//Initalize texture stuff


//TODO
//
		glGenTextures(1, &texture);
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, texture);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, WIDTH, HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);
		glBindImageTexture(0, texture, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA32F);
	*/		
	}

		//Update stuff
	
}


// handles keyboard input events
void KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);
    if (key == GLFW_KEY_E && action == GLFW_PRESS){
		scene++;
    	changeScene();
    }
    if (key == GLFW_KEY_Q && action == GLFW_PRESS){
		scene--;
		changeScene();
    }

}


void Render(){
	glClearColor(0.2, 0.2, 0.2, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);

//	cout << "cprog" << endl;
	glUseProgram(cprog);
//	check_glerror();
//	glDispatchCompute((GLuint)WIDTH, (GLuint)HEIGHT, 1);

//	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
//	cout << "clear" << endl;
//	glClear(GL_COLOR_BUFFER_BIT);
//	check_glerror();

//	cout << "use" << endl;
//    glUseProgram(tdraw);
//	check_glerror();

//    glActiveTexture(GL_TEXTURE0);
//    glBindTexture(GL_TEXTURE_2D, texture);

//	cout << "Draw" << endl;
//    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
//
	
    glBindVertexArray(vao);
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
//	check_glerror();
	return;
}
int main(int argc, char * argv[]){
	changeScene();	//Load up a scene!

	GLFWwindow * window = glfw_init(WIDTH,HEIGHT,"Scott Saunders - Assignment 4");	//Init window.

	glDebugMessageCallback(	GL_error_callback, NULL);

	glEnable(GL_DEBUG_OUTPUT);
	glEnable( GL_DEBUG_OUTPUT_SYNCHRONOUS);	
		Render();
//	while(!glfwWindowShouldClose(window)){ //Main loop.
    	glfwSwapBuffers(window);
		glfwPollEvents();
//	}
	
	glfwTerminate();	//Kill the glfw interface

}
